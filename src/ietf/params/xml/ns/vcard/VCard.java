//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4-2
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2013.04.12 at 11:58:52 AM EDT
//
package ietf.params.xml.ns.vcard;

import ietf.params.xml.ns.vcard.property.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.*;

/**
 * Java class for VCard complex type.
 * <p/>
 * This java class is built from the xCard definition: vCard XML Representation
 * draft-ietf-vcarddav-vcardxml-10
 * <p/>
 * From vCard MIME Directory Profile: Profile name: VCARD
 * <p/>
 * Profile purpose: To hold person object or white-pages type of directory
 * information. The person schema captured in the directory entries is that
 * commonly found in an electronic business card.
 * <p/>
 * The vCard object MUST contain the FN, N and VERSION types. The type-grouping
 * feature of [MIME-DIR] is supported by this profile to group related vCard
 * properties about a directory entry. For example, vCard properties describing
 * WORK or HOME related characteristics can be grouped with a unique group
 * label.
 * <p/>
 * The profile permits the use of non-standard types (i.e., those identified
 * with the prefix string "X-") as a flexible method for implementations to
 * extend the functionality currently defined within this profile.
 * <p/>
 * See http://tools.ietf.org/html/draft-ietf-vcarddav-vcardxml,
 * http://tools.ietf.org/html/draft-ietf-vcarddav-vcardrev-19 and
 * https://www.bedework.org/svn/bwxml/releases/bedework-3.8/schemas/vcard/vcard.xsd
 * <p/>
 * See http://tools.ietf.org/html/rfc2426 for type definitions.
 * <p/>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "VcardType", propOrder = {
  "propertiesOrGroup"
})
@XmlRootElement
public class VCard {

  /**
   * propertiesOrGroup is either an ArrayList of ArrayOfProperties OR a
   * GroupType objects.
   * <p/>
   * The GroupType object contains a group name and an ArrayOfProperties.
   * <p/>
   * Most always this will be a list of ArrayOfProperties objects. The getters
   * and setters assume a list of ArrayOfProperties.
   */
  @XmlElements({
    @XmlElement(name = "properties", type = ArrayOfProperties.class),
    @XmlElement(name = "group", type = GroupType.class)
  })
  protected List<Object> propertiesOrGroup;

  /**
   * Gets the value of the propertiesOrGroup property.
   * <p/>
   * This access method returns a reference to the live list, not a snapshot.
   * Therefore any modification you make to the returned list will be present
   * inside the JAXB object. This is why there is not a
   * <CODE>set</CODE> method for the propertiesOrGroup property.
   * <p/>
   * For example, to add a new item, do as follows:
   * <pre>
   *    getPropertiesOrGroup().add(newItem);
   * </pre>
   * <p/>
   */
  public List<Object> getPropertiesOrGroup() {
    if (propertiesOrGroup == null) {
      propertiesOrGroup = new ArrayList<Object>();
    }
    return this.propertiesOrGroup;
  }

  public boolean isSetPropertiesOrGroup() {
    return ((this.propertiesOrGroup != null) && (!this.propertiesOrGroup.isEmpty()));
  }

  public void unsetPropertiesOrGroup() {
    this.propertiesOrGroup = null;
  }

  /**
   * To help with new object creation this method will try to initialize the
   * propertiesOrGroup if it is not set.
   * <p/>
   * For marshalled objects this method may return null if the propertiesOrGroup
   * parameter does not include an ArrayOfProperties;
   * <p/>
   * @return the first available ArrayOfProperties entry in the
   *         propertiesOrGroup list.
   */
  public ArrayOfProperties getArrayOfProperties() {
    if (getPropertiesOrGroup().isEmpty()) {
      propertiesOrGroup.add(new ArrayOfProperties());
    }
    for (Object object : propertiesOrGroup) {
      if (object instanceof ArrayOfProperties) {
        return (ArrayOfProperties) object;
      }
    }
    return null;
  }

  /**
   * To help with new object creation this method will try to initialize the
   * propertiesOrGroup if it is not set.
   * <p/>
   * For marshalled objects this method may return null if the propertiesOrGroup
   * parameter does not include an GroupType;
   * <p/>
   * @return the first available GroupType entry in the propertiesOrGroup list.
   */
  public GroupType getGroupType() {
    if (getPropertiesOrGroup().isEmpty()) {
      propertiesOrGroup.add(new GroupType());
    }
    for (Object object : propertiesOrGroup) {
      if (object instanceof GroupType) {
        return (GroupType) object;
      }
    }
    return null;
  }

  /**
   * Get the FN Type Definition.
   * <p/>
   * To specify the formatted text corresponding to the name of the object the
   * vCard represents. This type is based on the semantics of the X.520 Common
   * Name attribute. The property MUST be present in the vCard object.
   * <p/>
   * e.g. FN:Mr. John Q. Public\, Esq.
   * <p/>
   * @return the FN Type Definition.
   */
  public String getFN() {
    /**
     * QName {urn:ietf:params:xml:ns:vcard-4.0}fn is a TextPropertyType.
     */
    JAXBElement jAXBElement = findJaXBElement("FN");
    if (jAXBElement != null) {
      return ((TextPropertyType) jAXBElement.getValue()).getText();
    } else {
      return null;
    }
  }

  public void setFN(String fn) {
    if (fn != null && !fn.isEmpty()) {
      getArrayOfProperties().setProperty(new ObjectFactory().createFn(new TextPropertyType(fn)));
    }
  }

  /**
   * Get the ORG Type Definition
   * <p/>
   * To specify the organizational name and units associated with the vCard. The
   * type is based on the X.520 Organization Name and Organization Unit
   * attributes. The type value is a structured type consisting of the
   * organization name, followed by one or more levels of organizational unit
   * names.
   * <p/>
   * Type example: A type value consisting of an organizational name,
   * organizational unit #1 name and organizational unit #2 name.
   * <p/>
   * e.g. ORG:ABC\, Inc.;North American Division;Marketing
   * <p/>
   * @return the ORG Type Definition
   */
  public String getORG() {
    /**
     * QName {urn:ietf:params:xml:ns:vcard-4.0}org is a TextListPropertyType.
     */
    JAXBElement jAXBElement = findJaXBElement("ORG");
    if (jAXBElement != null) {
      return ((TextListPropertyType) jAXBElement.getValue()).getEntry();
    } else {
      return null;
    }
  }

  public void setORG(String org) {
    if (org != null && !org.isEmpty()) {
      getArrayOfProperties().setProperty(new ObjectFactory().createOrg(new TextListPropertyType(org)));
    }
  }

  /**
   * Get the Street Address (ADR) Type Definition
   * <p/>
   * To specify the components of the delivery address for the vCard object. A
   * single structured text value, separated by the SEMI-COLON character (ASCII
   * decimal 59).
   * <p/>
   * The structured type value consists of a sequence of address components. The
   * component values MUST be specified in their corresponding position. The
   * structured type value corresponds, in sequence, to the post office box; the
   * extended address; the street address; the locality (e.g., city); the region
   * (e.g., state or province); the postal code; the country name. When a
   * component value is missing, the associated component separator MUST still
   * be specified.
   * <p/>
   * The text components are separated by the SEMI-COLON character (ASCII
   * decimal 59). Where it makes semantic sense, individual text components can
   * include multiple text values (e.g., a "street" component with multiple
   * lines) separated by the COMMA character (ASCII decimal 44).
   * <p/>
   * Type example: In this example the post office box and the extended address
   * are absent. ADR;TYPE=dom,home,postal,parcel:;;123 Main Street;Any
   * Town;CA;91921-1234
   * <p/>
   * @return the ADR Type Definition
   */
  public AdrPropertyType getADR() {
    /**
     * QName {urn:ietf:params:xml:ns:vcard-4.0}adr is a AdrPropertyType
     */
    JAXBElement jAXBElement = findJaXBElement("ADR");
    if (jAXBElement != null) {
      return (AdrPropertyType) jAXBElement.getValue();
    } else {
      return null;
    }
  }

  public void setADR(AdrPropertyType adrPropertyType) {
    getArrayOfProperties().setProperty(new ObjectFactory().createAdr(adrPropertyType));
  }

  /**
   * Get the EMAIL Type Definition
   * <p/>
   * To specify the electronic mail address for communication with the object
   * the vCard represents. A single text value.
   * <p/>
   * The type can include the type parameter "TYPE" to specify the format or
   * preference of the electronic mail address. The TYPE parameter values can
   * include: "internet" to indicate an Internet addressing type, "x400" to
   * indicate a X.400 addressing type or "pref" to indicate a preferred-use
   * email address when more than one is specified. Another IANA registered
   * address type can also be specified. The default email type is "internet". A
   * non-standard value can also be specified.
   * <p/>
   * e.g. EMAIL;TYPE=internet:jqpublic@xyz.dom1.com
   * <p/>
   * @return the EMAIL Type Definition
   */
  public String getEMAIL() {
    /**
     * QName {urn:ietf:params:xml:ns:vcard-4.0}email is a TextPropertyType
     */
    JAXBElement jAXBElement = findJaXBElement("EMAIL");
    if (jAXBElement != null) {
      return ((TextPropertyType) jAXBElement.getValue()).getText();
    } else {
      return null;
    }
  }

  public void setEMAIL(String email) {
    if (email != null || !email.isEmpty()) {
      getArrayOfProperties().setProperty(new ObjectFactory().createEmail(new TextPropertyType(email)));
    }
  }

  /**
   * Get the TEL Type Definition. This is the PHONE-NUMBER.
   * <p/>
   * To specify the telephone number for telephony communication with the object
   * the vCard represents.
   * <p/>
   * The value of this type is specified in a canonical form in order to specify
   * an unambiguous representation of the globally unique telephone endpoint.
   * This type is based on the X.500 Telephone Number attribute.
   * <p/>
   * The "phone-number" value type specifies that the type value is a telephone
   * number. This value type can be specified in the TEL type. The value type is
   * a text value that has the special semantics of a telephone number as
   * defined in [CCITT E.163] and [CCITT X.121].
   * <p/>
   * Type example: TEL;TYPE=work,voice,pref,msg:+1-213-555-1234
   * <p/>
   * @return the PHONE-NUMBER component of the TEL type definition. The URI
   *         component is ignored.
   */
  public String getTEL() {
    /**
     * QName {urn:ietf:params:xml:ns:vcard-4.0}tel is a TextUriPropertyType
     */
    JAXBElement jAXBElement = findJaXBElement("TEL");
    if (jAXBElement != null) {
      return ((TextUriPropertyType) jAXBElement.getValue()).getText();
    } else {
      return null;
    }
  }

  public void setTEL(String tel) {
    if (tel != null && !tel.isEmpty()) {
      getArrayOfProperties().setProperty(new ObjectFactory().createTel(new TextUriPropertyType(null, tel)));
    }
  }

  /**
   * Scans the propertiesOrGroup looking for a QName local part that matches the
   * input name.
   * <p/>
   * @param qNameLocalPart the QName local part (e.g. 'fn'). The QName search is
   *                       not case sensitive.
   * @return the corresponding JaXBElement, null if not found.
   */
  private JAXBElement findJaXBElement(String qNameLocalPart) {
    for (Object object : getPropertiesOrGroup()) {
      if (object instanceof ArrayOfProperties) {
        ArrayOfProperties arrayOfProperties = (ArrayOfProperties) object;
        for (JAXBElement<? extends BasePropertyType> jAXBElement : arrayOfProperties.getBaseProperty()) {
          if (qNameLocalPart.equalsIgnoreCase(jAXBElement.getName().getLocalPart())) {
            return jAXBElement;
          }
        }
      } else if (object instanceof GroupType) {
        GroupType groupType = (GroupType) object;
        for (JAXBElement<? extends BasePropertyType> jAXBElement : groupType.getProperties().getBaseProperty()) {
          if (qNameLocalPart.equalsIgnoreCase(jAXBElement.getName().getLocalPart())) {
            return jAXBElement;
          }
        }
      }
    }
    return null;
  }

  /**
   * Hashcode based on values in the object list, not on the objects themselves.
   * This is to ensure a consistent hashcode is produced for a given VCard
   * configuration.
   * <p/>
   * Hashcode is calculated from FM, ORG, EMAIL, ADR and TEL.
   * <p/>
   * @return
   */
  @Override
  public int hashCode() {
    int hash = 3;
    hash = 83 * hash + Objects.hashCode(getFN());
    hash = 83 * hash + Objects.hashCode(getEMAIL());
    hash = 83 * hash + Objects.hashCode(getORG());
    hash = 83 * hash + Objects.hashCode(getTEL());
    hash = 83 * hash + Objects.hashCode(getADR());
    return Math.abs(hash);
  }

  /**
   * Equality is calculated from FM, ORG, ADR and TEL.
   * <p/>
   * @param obj the other object to compare
   * @return TRUE if FM, ORG, EMAIL, ADR and TEL fields are equal.
   */
  @Override
  public boolean equals(Object obj) {
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    final VCard other = (VCard) obj;
    if (this.hashCode() != obj.hashCode()) {
      return false;
    }
    return true;
  }

  @Override
  public String toString() {
    return "VcardType"
      + " FN [" + getFN()
      + "] EMAIL [" + getEMAIL()
      + "] ORG [" + getORG()
      + "] TEL [" + getTEL()
      + "] ADR [" + getADR()
      + ']';
  }
}
